<?php

use Drupal\Component\Utility\String;
use Drupal\Core\Form\FormStateInterface;

/**
 * Implements hook_form_FORM_ID_alter() for user_form().
 */
function password_policy_form_user_form_alter(&$form, &$form_state) {
  //TODO - Password editing of existing account is broken, AJAX reloads current password and password multiple times

  //user interface changes
  //TODO - Consider hiding Password Strength indicator and Password Recommendations
  $form['account']['roles']['#weight'] = '0';
  $form['account']['mail']['#weight'] = '1';
  $form['account']['name']['#weight'] = '2';
  $form['account']['status']['#weight'] = '5';
  $form['account']['notify']['#weight'] = '6';

  //update password field
  $form['account']['pass']['#title'] = 'Password';
  //TODO - Removing password confirm (does not have any AJAX call) causes error on AJAX
  $form['account']['pass']['#type'] = 'password';
  $form['account']['pass']['#weight'] = '3';


  $form['account']['password_policy_status'] = array(
    '#title' => 'Password policies',
    '#type' => 'table',
    '#header' => array(t('Policy'), t('Status'), t('Constraint')),
    '#empty' => t('There are no constraints for the selected user roles'),
    '#weight' => '4',
    '#prefix' => '<div id="password-policy-status">',
    '#suffix' => '</div>',
    '#rows' => _password_policy_constraints_table($form, $form_state),
  );

  //set ajax changes
  $form['account']['roles']['#ajax'] = array(
    'event' => 'change',
    'callback' => '_password_policy_check_constraints',
    'method' => 'replace',
    'wrapper' => 'password-policy-status',
  );

  $form['account']['pass']['#ajax'] = array(
    'event' => 'change',
    'callback' => '_password_policy_check_constraints',
    'method' => 'replace',
    'wrapper' => 'password-policy-status',
  );

  //dpm($form);

  //add callback to reset password expiration if new password supplied
  //$form['actions']['submit']['#submit'][] = '_password_policy_user_profile_form_submit';
  $form['actions']['submit']['#validate'][] = '_password_policy_user_profile_form_validate';
}

/**
 *  Check if password policies failed
 */
function _password_policy_user_profile_form_validate(&$form, $form_state) {
  $roles = $form_state->getValue('roles');

  $applicable_policies = array();

  foreach ($roles as $role_key => $role_enabled) {
    if ($role_enabled) {
      $role_map = array('roles.'.$role_key => $role_key);
      $role_policies = entity_load_multiple_by_properties('password_policy', $role_map);
      $applicable_policies = array_unique(array_merge($applicable_policies, $role_policies));
    }
  }

  //run validation
  $failed = FALSE;

  foreach ($applicable_policies as $policy_id => $policy) {
    $policy_constraints = $policy->getConstraints();

    foreach ($policy_constraints as $constraint_id => $constraint) {


      $plugin_inst = \Drupal::service('plugin.manager.password_policy.password_constraint');

      $plugin_object = $plugin_inst->createInstance($constraint['id'], $constraint);

      //execute validation
      $validation = $plugin_object->validate($form_state->getValue('pass'));

      if (!$validation->isValid() and !$failed and $form_state->getValue('pass') != '') {
        //throw error to ensure form will not submit
        $failed = TRUE;
      }

    }
  }





  if ($failed) {
    $form_state->setErrorByName('pass', 'The password does not satisfy the password policies');
  }
}

/**
 *  Implements hook_user_insert().
 */
function password_policy_user_insert($account) {
  db_insert('password_policy_user_reset')
    ->fields(array(
      'uid' => $account->id(),
      'expired' => '0',
      'timestamp' => time()
    ))
    ->execute();
}

/**
 *  Implements hook_user_update().
 */
function password_policy_user_update($account) {
  db_update('password_policy_user_reset')
    ->fields(array('expired' => '0', 'timestamp' => time()))
    ->condition('uid', $account->id())
    ->execute();
}

/**
 * AJAX callback for user form
 */
function _password_policy_check_constraints($form, $form_state) {
  return $form['account']['password_policy_status'];
}

/**
 * AJAX callback for user form
 */
function _password_policy_constraints_table($form, $form_state) {

  $roles = $form_state->getValue('roles');

  //add user doesn't automatically register authenticated, so lets add it
  if (empty($roles)) {
    $roles = array('authenticated' => 'authenticated');
  }

  //run validation
  $table_rows = array();
  $failed = FALSE;
  $applicable_policies = array();

  foreach ($roles as $role_key => $role_enabled) {
    if ($role_enabled) {
      $role_map = array('roles.'.$role_key => $role_key);
      $role_policies = entity_load_multiple_by_properties('password_policy', $role_map);
      $applicable_policies = array_unique(array_merge($applicable_policies, $role_policies));
    }
  }

  //run validation
  $failed = FALSE;

  foreach ($applicable_policies as $policy_id => $policy) {
    $policy_constraints = $policy->getConstraints();

    foreach ($policy_constraints as $constraint_id => $constraint) {


      $plugin_inst = \Drupal::service('plugin.manager.password_policy.password_constraint');

      $plugin_object = $plugin_inst->createInstance($constraint['id'], $constraint);

      //execute validation
      $validation = $plugin_object->validate($form_state->getValue('pass'));

      if ($validation->isValid()) {
        $status = 'Pass';
      }
      else {
        $status = 'Fail - ' . $validation->getErrorMessage();
        //throw error to ensure form will not submit
        if (!$failed and $form_state->getValue('pass') != '') {
          //set storage value since you cant throw errors here
          $storage = $form_state->getStorage();
          $storage['password_fails_policies'] = TRUE;
          $form_state->setStorage($storage);
          $failed = TRUE;
        }
      }

      $table_row = array(
        'policy' => $policy->label(),
        'status' => $status,
        'constraint' => $plugin_object->getSummary(),
      );
      $table_rows[] = $table_row;

    }
  }

  //if no role, show default message
  return $table_rows;
}

/**
 * Implements hook_cron().
 *
 * Looks for expired passwords and updates the expiration based on the policy assigned
 */
function password_policy_cron() {
  //TODO - Update password reset expiration
  $policies = db_select('password_policy_reset', 'ppr')
    ->fields('ppr', array())
    ->execute()
    ->fetchAll();

  /**
   * TODO - Identify a way to improve this, performance may suck with large # of users
   */

  //get all roles
  $users = \Drupal\user\Entity\User::loadMultiple();
  $expirations = db_select("password_policy_user_reset", "ur")
    ->fields("ur", array())
    ->execute()
    ->fetchAll();
  $user_expiration = array();
  foreach ($expirations as $expiration) {
    $key = $expiration->uid;
    $user_expiration[$key] = array(
      'timestamp' => $expiration->timestamp,
      'expired' => $expiration->expired
    );
  }

  //check each policy
  foreach ($policies as $policy) {
    //check each user for this permission
    foreach ($users as $user) {
      if ($user->hasPermission('enforce password_reset.' . $policy->pid . ' constraint')) {
        //get expiration record
        $user_expiration_record = $user_expiration[$user->id()];

        //check if expired
        if ($user_expiration_record['expired'] != '1' and $user_expiration_record['timestamp'] <= strtotime("-" . $policy->number_of_days . ' days')) {
          //expire
          db_update("password_policy_user_reset")
            ->fields(array("expired" => '1'))
            ->condition('uid', $user->id())
            ->execute();
        }
      }
    }
  }
}

/**
 * Menu argument loader. Returns a password policy entity
 *
 * @param $id
 * @return \Drupal\Core\Entity\EntityInterface|static
 */
function password_policy_load($id) {
  return \Drupal\password_policy\Entity\PasswordPolicy::load($id);
}