<?php

use Drupal\Component\Utility\String;
use Drupal\Core\Form\FormStateInterface;

/**
 * Implements hook_form_FORM_ID_alter() for user_form().
 */
function password_policy_form_user_form_alter(&$form, &$form_state) {
	/**
	 * Use cases:
	 * -Add User - how do we know which role? this should come first with an AJAX on change
	 */
	//dpm($form);
	//$form['#validate'][] = 'user_restrictions_validate';

	//dpq($form_state);

	//user interface changes
	//TODO - Consider hiding Password Strength indicator and Password Recommendations
	$form['account']['roles']['#weight'] = '0';
	$form['account']['mail']['#weight'] = '1';
	$form['account']['name']['#weight'] = '2';
	$form['account']['status']['#weight'] = '5';
	$form['account']['notify']['#weight'] = '6';

	//update password field
	$form['account']['pass']['#title'] = 'Password';
	//TODO - Removing password confirm (does not have any AJAX call) causes error on AJAX
	$form['account']['pass']['#type'] = 'password';
	$form['account']['pass']['#weight'] = '3';

	$form['account']['password_policy_status'] = array(
		'#title' => 'Password policies',
		'#type' => 'table',
		'#header' => array(t('Status'), t('Constraint')),
		'#empty' => t('There are no constraints for the selected user roles'),
		'#weight' => '4',
		'#prefix' => '<div id="password-policy-status">',
		'#suffix' => '</div>',
		'#rows' => _password_policy_constraints_table($form, $form_state),
	);

	//set ajax changes
	$form['account']['roles']['#ajax'] = array(
		'event' => 'change',
		'callback' => '_password_policy_check_constraints',
		'method' => 'replace',
		'wrapper' => 'password-policy-status',
	);

	$form['account']['pass']['#ajax'] = array(
		'event' => 'change',
		'callback' => '_password_policy_check_constraints',
		'method' => 'replace',
		'wrapper' => 'password-policy-status',
	);
}

/**
 * AJAX callback for user form
 */
function _password_policy_check_constraints($form, $form_state) {
	return $form['account']['password_policy_status'];
}

/**
 * AJAX callback for user form
 */
function _password_policy_constraints_table($form, $form_state) {

	//$plugin_manager = \Drupal::service('plugin.manager.password_policy.password_constraint');
	//$user_constraints = $plugin_manager->getDefinitions();
	//dpm($plugins);

	$roles = $form_state->getValue('roles');

	//add user doesn't automatically register authenticated, so lets add it
	if(empty($roles)){
		$roles = array('authenticated'=>'1');
	}

	//only load these once time for performance
	$plugin_manager = \Drupal::service('plugin.manager.password_policy.password_constraint');
	$plugin_manager->getDefinitions();

	//get constraints for selected roles
	$all_plugins = $plugin_manager->getDefinitions();
	$policy_duplicates = array();
	$table_rows = array();
	foreach($roles as $role_key=>$role_value) {
		$role = \Drupal\user\Entity\Role::load($role_key);
		foreach ($all_plugins as $plugin) {
			$constraint_inst = \Drupal::service('plugin.manager.password_policy.password_constraint')->createInstance($plugin['id']);
			$policies = $constraint_inst->getPolicies();
			foreach ($policies as $policy_key => $policy_text) {
				if ($role->hasPermission('enforce ' . $plugin['id'] . '.' . $policy_key . ' constraint') and !in_array($plugin['id'] . '.' . $policy_key, $policy_duplicates)) {
					$table_row = array('constraint' => $policy_text);
					if(!$constraint_inst->validate($policy_key, $form_state->getValue('pass'))){
						$table_row['status'] = 'Fail';
					} else {
						$table_row['status'] = 'Pass';
					}
					$table_rows[] = $table_row;
					$policy_duplicates[] = $plugin['id'] . '.' . $policy_key;
				}
			}
		}
	}
	//dpm($user_constraints);

	//verify and display password for constraints
	/*$table_rows = array();
	foreach($user_constraints as $constraint){
		//TODO - Need to evaluate config parameters here
		$table_row = array('constraint' => $constraint['description']);
		$constraint_inst = \Drupal::service('plugin.manager.password_policy.password_constraint')->createInstance($constraint['id']);
		if(!$constraint_inst->validate($form_state->getValue('pass'))){
			$table_row['status'] = 'Fail';
		} else {
			$table_row['status'] = 'Pass';
		}
		$table_rows[] = $table_row;
	}*/

	//if no role, show default message
	return $table_rows;
}

/**
 * Load the plugins for a role
 */
function _password_policy_get_policies_by_role($role_key, $constraint_id) {
	$role = \Drupal\user\Entity\Role::load($role_key);
	$role_constraints = array();

	$all_plugins = $plugin_manager->getDefinitions();
	foreach($all_plugins as $plugin) {
		$policies = $plugin->getPolicies();
		foreach($policies as $policy_key => $policy_text) {
			if ($role->hasPermission('enforce ' . $plugin->id . '.'.$policy_key.' constraint')) {
				$role_constraints[] = $plugin;
			}
		}
	}

	return $role_constraints;
}

/**
 * Submit handler for policies
 */
function _password_policy_register_policy() {
	//save policy
}

/**
 * Implements hook_cron().
 *
 * Looks for expired passwords and updates the expiration based on the policy assigned
 */
function password_policy_cron() {
	//TODO - Update password reset expiration
	$policies = db_select('password_policy_reset', 'ppr')
		->fields('ppr', array())
		->execute()
		->fetchAll();

	//get all roles
	$roles = \Drupal\user\Entity\Role::loadMultiple();

	foreach($policies as $policy) {
		//generate expiration timestamp
		$expired_timestamp = strtotime("-".$policy->number_of_days." days");
		//check each role for this permission
		foreach($roles as $role){
			if($role->hasPermission('enforce password_reset.'.$policy->pid.' constraint')){
				//get all users with this role
				$role_users = db_select("users", 'u')
					->fields('u', array('uid'));
				$role_users->join('users_roles', 'ur', 'ur.uid=u.uid');

				$role_users->condition('ur.rid', $role->rid)
					->execute()
					->fetchAll();
				//flatten array
				$user_array = array();
				foreach($role_users as $user){
					$user_array[] = $user->uid;
				}
				//update users conditionally based on their timestamp
				db_update("password_policy_user_reset")
					->fields(array("expired"=>'1'))
					->condition('uid', $user_array, 'IN')
					->condition("timestamp", $expired_timestamp, "<=")
					->execute();
			}
		}
	}
}